<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java API——String与ArrayList</title>
    <link href="/2025/04/01/java01/"/>
    <url>/2025/04/01/java01/</url>
    
    <content type="html"><![CDATA[<p>Java API是java提供给我们的程序，其构成也是多个类组成的包</p><h1 id="包-Package"><a href="#包-Package" class="headerlink" title="包|Package"></a>包|Package</h1><p>包用来管理不同的程序  </p><p><font size='3'>那么一类如何调用包中的另一个类呢？</font></p><ul><li>调用相同包的类：无需import，创建另一个类的类类型实例，直接就可调用。</li><li>调用不同包的类:需要写入import 包名.类名，再创建另一个类的类类型实例，便可调用。</li><li>调用java提供的类（API）：需要写入import 包名.类名，再创建另一个类的类类型实例，便可调用；但java.lang包下的类不需要import。</li><li>调用相同名称却在不同包中的类：只能import其中一个类，当需要调用另一个类时，则需要写全——包名.类名才可调用。</li></ul><h1 id="String"><a href="#String" class="headerlink" title="String"></a>String</h1><h2 id="String概述"><a href="#String概述" class="headerlink" title="String概述"></a>String概述</h2><p>String类在java.lang包中<br>它代表字符串，可以创建字符串并且对其进行封装，对其进行处理。String封装数据的方式有两种：①直接利用””；②利用new String()封装器</p><ul><li>直接给变量赋值字符串，封装字符串:<code>String str=&quot;abc&quot;;</code></li><li>利用构造器创建字符串对象并初始化：<code>String str=new String();</code></li><li>利用构造器从字符数组中获取字符串：<code>char[] chars=&#123;&#39;a&#39;,&#39;b&#39;,&#39;c&#39;&#125;;  String str=new String(chars);</code></li><li>利用构造器从字节数组中获得字符串：<code>byte[] bytes=&#123;97,98,99&#125;;  String str=new String(bytes);//最后输出为abc</code></li></ul><h2 id="String常用方法"><a href="#String常用方法" class="headerlink" title="String常用方法"></a>String常用方法</h2><p><code>String str=&quot;Java是世界上最好的编程语言之一&quot;</code></p><ul><li><p><strong>charAt(int i)</strong>：获取索引i位置的字符。<code>char c=str.charAt(1);//结果为a</code><br>   可用于字符的遍历：快捷用法：<code>str.length().fori</code>回车补全for循环——&gt;</p>   <figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">for</span>(<span class="hljs-built_in">int</span> i=<span class="hljs-number">0</span>;i&lt;<span class="hljs-built_in">str</span>.length();i++)&#123;<span class="hljs-comment">//注意：字符串获取长度有()</span><br>   <span class="hljs-built_in">char</span> c=<span class="hljs-built_in">str</span>.charAt(i);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><strong>length()</strong>:获取字符串的长度。<code>int n=str.length();//结果为17</code> </p></li><li><p><strong>toCharArray()</strong>:将字符串转变为字符数组。<code>char[] chars=str.toCharArray; int n=chars.length;//注意：数组获取长度无()</code>  </p></li><li><p><strong>equals()</strong>:比较两个字符串内容是否相同。<code>String str1=&quot;abc&quot;; boolean b=str.equals(str1);//结果为false</code><br>注意：&#x3D;&#x3D;符号比较的是两个字符串引用的实例是否相同  </p></li><li><p><strong>equalsIgnoreCase()</strong>:忽略字母大小写比较两个字符串内容是否相同（一般用于验证码）。<code>String str1=&quot;abc&quot;; String str2=&quot;ABc&quot;; boolean b=str1.equalsIgnoreCase(str2);//结果为true</code>  </p></li><li><p><strong>subString(int i,int j)</strong>:截取索引i到j的字符串（包括i不包括j）。<code>String s=str.subString(0,4);//结果为java</code><br>这里有个小技巧，不需要自己去数末尾字符的索引，选中要截取的字符串，IDEA右下角就会出现选中字符串的长度</p></li><li><p><strong>subString(int i)</strong>:截取索引i后面所有的字符串</p></li><li><p><strong>replace(“A”,”B”)</strong>:用B代替A，返回字符串。<code>String str3=str.replace(&quot;Java&quot;,&quot;C&quot;);//结果为&quot;C是世界上最好的编程语言之一&quot;</code></p></li><li><p><strong>contains(“A”)</strong>:判断字符串中是否包含A。<code>boolean d=str.contains(&quot;Java&quot;);//结果为true</code></p></li><li><p><strong>startswith(“A”)</strong>:判断字符串是否由A开头。<code>boolean c=str.startswith(&quot;Java1&quot;);//结果为false</code></p></li><li><p><strong>split(“A”)</strong>:根据A进行分割字符串，获得一个字符串数组。<code>String str4=&quot;Java,C,C++,Go&quot;; String[] str5=str4.split(&quot;,&quot;);</code></p></li></ul><h2 id="String使用时的注意事项"><a href="#String使用时的注意事项" class="headerlink" title="String使用时的注意事项"></a>String使用时的注意事项</h2><ul><li><p><strong>String对象是不可变的字符串对象，一旦被创建它的内容就是无法被修改的，通常只是又创建了一个新的字符串对象（新地址），由另外一个字符串对象去引用它</strong></p></li><li><p><strong>利用””创建的两个字符串对象，若它们内容相同，那么两个字符串对象便相等</strong>：这是因为””创建的内容相同的字符串常量被放到了堆内存的字符串常量池中，栈内存内的字符串对象只需引用那一个即可（也就是字符串对象引用的实例（的地址）相同）。<code>String str1=&quot;abc&quot;; String str2=&quot;abc&quot;; System.out.print(str1==str2);//结果为true</code></p></li><li><p><strong>利用new创建的两个字符串对象，即使内容相同，它们也不相等</strong> ：使用new每创建一个字符串对象，堆内存便会创建一个新的地址来存放该对象，栈内存内的两个字符串对象需要分别引用它们,（也就是字符串对象引用的实例（的地址）不同了）。<code>String str1=new String(&quot;abc&quot;); String str2=new String(&quot;abc&quot;);; System.out.print(str1==str2);//结果为flase</code></p></li></ul><p><font size="4"><strong>练习题</strong>：这段代码<code>String str=new String(&quot;abc&quot;)</code>创建了几个字符串对象</font></p><p>答案是：两个，程序先在堆内存的字符串常量池中创建了”abc”对象，又利用new在堆内存创建了新的字符串对象。</p><h2 id="开发案例"><a href="#开发案例" class="headerlink" title="开发案例"></a>开发案例</h2><h3 id="登录页面"><a href="#登录页面" class="headerlink" title="登录页面"></a>登录页面</h3><p>开发一个登录页面，要求如下：</p><ul><li>允许用户登录三次，三次不成功退出系统</li><li>登录成功显示”欢迎进入系统”</li><li>登录不成功前两次要求用户重新输入账号密码</li></ul><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs typescript">package com.<span class="hljs-property">itheima</span>.<span class="hljs-property">pkg</span>;<br><br><span class="hljs-keyword">import</span> java.<span class="hljs-property">util</span>.<span class="hljs-property">Scanner</span>;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-title function_">main</span>(<span class="hljs-params"><span class="hljs-title class_">String</span>[] args</span>) &#123;<br>        <span class="hljs-comment">//开发登录界面</span><br>        <span class="hljs-title class_">Scanner</span> sc = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Scanner</span>(<span class="hljs-title class_">System</span>.<span class="hljs-property">in</span>);<br><br>        <span class="hljs-keyword">for</span> (int i=<span class="hljs-number">0</span>; i&lt;<span class="hljs-number">3</span>; i++) &#123;<br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;请输入账号：&quot;</span>);<br>            <span class="hljs-title class_">String</span> account=sc.<span class="hljs-title function_">nextLine</span>();<br><br>            <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;请输入密码：&quot;</span>);<br>            <span class="hljs-title class_">String</span> password=sc.<span class="hljs-title function_">nextLine</span>();<br><br>            <span class="hljs-keyword">if</span>(<span class="hljs-title function_">equals</span>(account,password))&#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;欢迎登录系统！&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-title class_">System</span>.<span class="hljs-property">out</span>.<span class="hljs-title function_">print</span>(<span class="hljs-string">&quot;请重新输入&quot;</span>);<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">boolean</span> <span class="hljs-title function_">equals</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> account, <span class="hljs-title class_">String</span> password</span>) &#123;<br>        <span class="hljs-title class_">String</span> account1=<span class="hljs-string">&quot;javazhifu&quot;</span>;<br>        <span class="hljs-title class_">String</span> password1=<span class="hljs-string">&quot;123456&quot;</span>;<br><br>        <span class="hljs-keyword">return</span> account1.<span class="hljs-title function_">equals</span>(account) &amp;&amp; password.<span class="hljs-title function_">equals</span>(password1);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>*快捷键使用：1.要想加入for循环，可以选中循环区域按<code>ctrl+alt+T</code>键便可。<br>2.输出语句快捷键：<code>要输入的内容.sout</code>按回车键</p><p style="color:red">*以下代码才是一个成熟的程序员写的，我们最初写的都是if条件语句</p><p><code>return account1.equals(account) &amp;&amp; password.equals(password1);</code></p><h3 id="验证码随机生成"><a href="#验证码随机生成" class="headerlink" title="验证码随机生成"></a>验证码随机生成</h3><p>随机生成n位验证码</p><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arduino">package com.itheima.pkg;<br><br><span class="hljs-keyword">import</span> java.util.Random;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">StringTest</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">void</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">String</span>[] args)</span> </span>&#123;<br>        System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">codes</span>(<span class="hljs-number">5</span>));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-type">static</span> <span class="hljs-type">String</span> <span class="hljs-title">codes</span><span class="hljs-params">(<span class="hljs-type">int</span> n)</span> </span>&#123;<br>        <span class="hljs-type">String</span> code = <span class="hljs-string">&quot;&quot;</span>;<br>        <span class="hljs-type">String</span> codeString = <span class="hljs-string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789&quot;</span>;<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; n; i++) &#123;<br>            Random random = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Random</span>();<br><br>            <span class="hljs-type">int</span> r=random.<span class="hljs-built_in">nextInt</span>(codeString.<span class="hljs-built_in">length</span>());<br>            code += codeString.<span class="hljs-built_in">charAt</span>(r);<br>        &#125;<br>        <span class="hljs-keyword">return</span> code;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h1 id="ArrayList集合"><a href="#ArrayList集合" class="headerlink" title="ArrayList集合"></a>ArrayList集合</h1><p>ArrayList是一种容器，用于存储数据，它与数组的区别是集合不限制长度，而数组的长度是固定的；例如购物车内商品的数量一般是能够随时增删的，这里用到的就是ArrayList。</p><h2 id="创建ArrayList对象"><a href="#创建ArrayList对象" class="headerlink" title="创建ArrayList对象"></a>创建ArrayList对象</h2><ul><li>不限制元素类型：<code>ArrayList list = new ArrayList();</code></li><li>限制元素类型：<code>ArrayList&lt;String&gt; list = new ArrayList&lt;&gt;();</code></li></ul><h2 id="ArrayList常用方法"><a href="#ArrayList常用方法" class="headerlink" title="ArrayList常用方法"></a>ArrayList常用方法</h2><p><code>ArrayList&lt;String&gt; list=new ArrayList&lt;&gt;();</code></p><ul><li><strong>boolean add(E e)</strong>:在集合末尾添加元素。<code>list.add(&quot;java&quot;)；list.add(&quot;C&quot;);//结果为true，[&quot;java&quot;,&quot;C&quot;]</code></li><li><strong>void add(int index,E e)</strong>:在索引index处添加元素e。<code>list.add(0,&quot;C&quot;);//[&quot;C&quot;,&quot;java&quot;,&quot;C&quot;]</code></li><li><strong>E remove(int index)</strong>:删除index索引处的元素，并返回该元素。<code>list.remove(0);//结果为true，[&quot;java&quot;,&quot;C&quot;]</code></li><li><strong>boolean remove(E e)</strong>:删除元素e，若有多个e，则删除最前面的e。<code>list.remove(&quot;java&quot;);//结果为true，[&quot;C&quot;]</code> </li><li><strong>E get(int index)</strong>:获取索引index处的元素，并返回该元素。<code>list.get(0);//结果为C,[]</code></li><li><strong>int size()</strong>:返回集合的个数。<code>list.size();//结果为0</code></li><li><strong>E set(int index,E e)</strong>:修改索引index处的元素为e，并返回e。</li></ul><h2 id="开发案例-1"><a href="#开发案例-1" class="headerlink" title="开发案例"></a>开发案例</h2><p>删除购物车中所有的枸杞</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs csharp">package com.itheima.pkg;<br><br>import java.util.ArrayList;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">StringTest</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span>(<span class="hljs-params">String[] <span class="hljs-keyword">args</span></span>)</span> &#123;<br>       ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>       list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;java入门&quot;</span>);<br>       list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;宁夏枸杞&quot;</span>);<br>       list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;黑枸杞&quot;</span>);<br>       list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;人字拖&quot;</span>);<br>       list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;特级枸杞&quot;</span>);<br>       list.<span class="hljs-keyword">add</span>(<span class="hljs-string">&quot;枸杞子&quot;</span>);<br><br>        System.<span class="hljs-keyword">out</span>.println(removeE(list));<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> ArrayList&lt;String&gt; <span class="hljs-title">removeE</span>(<span class="hljs-params">ArrayList&lt;String&gt; list</span>)</span> &#123;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-built_in">int</span> i = <span class="hljs-number">0</span>; i &lt; list.size(); i++) &#123;<br>            <span class="hljs-keyword">if</span>(list.<span class="hljs-keyword">get</span>(i).contains(<span class="hljs-string">&quot;枸杞&quot;</span>))&#123;<br>                list.<span class="hljs-keyword">remove</span>(list.<span class="hljs-keyword">get</span>(i));<br>                i--;<span class="hljs-comment">//注意：这里要使i向前移一位，因为删掉一个元素之后后面的元素会自动向前移一位，如果i还向后移的话，就会忽略部分元素</span><br>            &#125;<br>        &#125;<span class="hljs-keyword">return</span> list;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如上述代码需要注意的是for循环中的i- -，这里也可以将for循环进行修改，倒序进行判断，就不用再考虑i- -的问题了，如下所示</strong>：</p><figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lisp">for (<span class="hljs-name">int</span> i = list.size()<span class="hljs-number">-1</span><span class="hljs-comment">; i &gt; 0; i--) &#123;</span><br>            if(<span class="hljs-name">list</span>.get(<span class="hljs-name">i</span>).contains(<span class="hljs-string">&quot;枸杞&quot;</span>))&#123;<br>                list.remove(<span class="hljs-name">list</span>.get(<span class="hljs-name">i</span>))<span class="hljs-comment">;</span><br>            &#125;<br>        &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot基础</title>
    <link href="/2025/03/31/Spring03/"/>
    <url>/2025/03/31/Spring03/</url>
    
    <content type="html"><![CDATA[<h1 id="检查Java环境"><a href="#检查Java环境" class="headerlink" title="检查Java环境"></a>检查Java环境</h1><p><img src="/image/s17.png" alt="alt"></p><h1 id="安装并配置Maven"><a href="#安装并配置Maven" class="headerlink" title="安装并配置Maven"></a>安装并配置Maven</h1><p>Maven时项目构建工具，能把项目抽象成POM（project object model）,Maven使用POM对项目进行构建、打包、文档化等操作，<strong>最重要的是解决了项目所需要类库的依赖管理，</strong> 简化了项目开发环境搭建的过程，使得我们开发一个大型复杂的项目变得更容易。  </p><h2 id="Maven的作用"><a href="#Maven的作用" class="headerlink" title="Maven的作用"></a>Maven的作用</h2><p>Maven最初用于替代Apache Ant.用来简化项目构建，它采用不同的方式对项目构建进行抽象，主要有以下几点：  </p><ul><li>使构建项目变得更加容易。</li><li>统一了构建项目的方式，通过pom.xml来描述项目，并提供一系列插件来构建项目。</li><li>提出一套开发项目的最佳实践，源码在src&#x2F;main&#x2F;java中，测试代码在src&#x2F;test&#x2F;java中，项目需要的配置文件则放在src&#x2F;main&#x2F;resources中。</li><li>包含不同环境项目的构建方式。</li><li>解决类库依赖的问题，只需要声明使用的类库，Maven就会自动从仓库下载依赖的jar包，并协助管理jar包之间的冲突。</li></ul><p><strong>在开发人员本地，Maven都会创建一个本地仓库来缓存已经下载的jar包，避免每次都去重新下载，如果不自行设置本地仓库地址，其默认仓库在用户目录下的隐藏文件夹中</strong>  </p><h2 id="Maven的核心"><a href="#Maven的核心" class="headerlink" title="Maven的核心"></a>Maven的核心</h2><p><strong>Maven的核心为pom.xml文件</strong><br>pom.xml文件用XML方式描述项目模型，pom通常有以下元素： </p><ul><li>groupId:表示项目所属的组,通常是一个公司或者组织的名称,如 org.springtramewot。</li><li>artifactId:项目唯一的标识，比如，有spring-boot-starter-web、spring-boot-devtool、groupld 和 artifactld 能唯一标识一个项目或者一个库，我们通常称之为项目坐标。</li><li>packaging:项目的类型，常用的有jar和war 两种，jar 表示项目会打包成一个jar包,这是 Spring Boot 的默认使用方式。</li><li>version:项目的版本号，比如0.0.1-SNAPSHOT、1.5.2.RELEASE。</li></ul><blockquote><p>通常来说，项目版本号分三段，主版本号.次版本号.修订版本号。主版本号变动代表架构变动或者不兼容实现，次版本号是兼容性修改、功能增强，修订版本号则是bug修复。</p><p>版本的后缀意味着项目的不同阶段，SNAPSHOT表示开发中的版本，会修复bug和添加新功能;RELEASE 表示的是一个正式发布版，中间还可能有M1、M2(M指里程碑，即将发布)RC(Release Candidate，发布候选)、GA(general availability，基本可用版本)等表示即将发布前的各个过程，SNAPSHOT&lt;m1&lt;m2…&lt;RC&lt;GA&lt;Realease。</p></blockquote><ul><li>modelVersion:代表pom文件的Maven的版本，如我i的项目的Maven的modelVersion 是4.0.0。</li><li>dependencies:此元素下包含了多个dependency，用来声明项目的依赖，&amp;<strong>这是pom最核心的部分。</strong></li><li>dependency:包含在dependencies中，用来声明项目的依赖，比如项目用到的MySQL驱动。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>依赖的坐标是 mysqlmysql-connector-java，版本号是6.0.5。</p><ul><li>scope:scope代表此类库与项目的关系，默认是compile，也就是编译和打包都需要此类库。test表示仅仅在单元测试的时候需要;provided表示在编译阶段需要此类库，但打包阶段不需要，这是因为项目的目标环境已经提供了;runtime 表示在编译和打包的时候都不需要，但在运行的时候需要，比如某个指定的数据库驱动，编译和打包都不需要，但测试应用要连到数据库时就需要此数据库驱动。</li><li>build:此项在 pom 中可选，build 包含了多个插件 plugin，用来辅助项目构建。Maven与以往的 Ant 等其他构建工具不同，Maven 已经约定俗成地包含了构建方法，插件可以在构建过程中影响项目的构建。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">encoding</span>&gt;</span>UTF-8<span class="hljs-tag">&lt;/<span class="hljs-name">encoding</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>     <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="检查Maven环境"><a href="#检查Maven环境" class="headerlink" title="检查Maven环境"></a>检查Maven环境</h2><p><img src="/image/s18.png" alt="alt">   </p><p><strong>注意：Maven安装路径下的conf&#x2F;settings.xml中mirrors元素中要添加仓库镜像</strong>  </p><p><img src="/image/s19.png" alt="alt"></p><h2 id="在IDEA中配置Maven"><a href="#在IDEA中配置Maven" class="headerlink" title="在IDEA中配置Maven"></a>在IDEA中配置Maven</h2><p><img src="/image/s20.png" alt="alt"></p><h2 id="Maven常见命令"><a href="#Maven常见命令" class="headerlink" title="Maven常见命令"></a>Maven常见命令</h2><ul><li>mvn package:编译并打包工程，更具pom.xml中元素packaging是jar还是war进行打包，会在target目录下生成一个jar包或war包。</li><li>mvn install:打包并安装到本地仓库，这样其他本地Maven项目就可以通过项目坐标引用。</li><li>mvn deploy:打包并安装到远程仓库</li><li>mvn clean:清楚target目录</li></ul><h2 id="Spring容器介绍"><a href="#Spring容器介绍" class="headerlink" title="Spring容器介绍"></a>Spring容器介绍</h2><h3 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring IOC"></a>Spring IOC</h3><p>IOC：Inversion of Control,反向控制原则，更为形象得称呼为DI（dependency injection,依赖注入）</p><p>Spring提供多个注解声明Bean为Spring管理的Bean，注释不同代表的含义不同，但对于Spring容器来说，都是Spring管理的Bean</p><ul><li>@Controller:声明此类是一个MVC类，通常和@RequestMapping一起使用。</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Controller</span><br><span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/user&quot;</span>)<br>public class UserController&#123;<br>    <span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/get/&#123;id&#125;&quot;</span>)<br>    public String <span class="hljs-built_in">getUser</span>(<span class="hljs-variable">@PathVariable</span> String id)&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上述代码，如果客户请求&#x2F;user&#x2F;get&#x2F;1;将调用getUser方法，并把参数1传给id。</p><ul><li>@Service：声明此类是一个业务处理类，通常与@Transactional一起配合使用。</li></ul><figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-variable">@Service</span><br><span class="hljs-variable">@Transactional</span><br>public class UserServiceImpl implements UserService&#123;<br>    <span class="hljs-selector-tag">public</span> <span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">order</span>(...)&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>@Repository:声明此类是一个数据库或者其他NoSQL访问类。</li></ul><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">@Repository<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-symbol">UserDao</span> <span class="hljs-symbol">implements</span> <span class="hljs-symbol">CruDao</span>&lt;<span class="hljs-symbol">User,<span class="hljs-symbol">String</span></span>&gt;&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>RestController:同Controller，用于REST服务。</li><li>Component:声明此类是一个Spring管理的类，通常用于无法用上述注解描述的Spring管理类。</li><li>Configuration:声明此类是一个配置类，通常与注解@Bean配合使用。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>利用Spring完成一个简单的Web应用</title>
    <link href="/2025/03/30/Spring02/"/>
    <url>/2025/03/30/Spring02/</url>
    
    <content type="html"><![CDATA[<h1 id="完成一个简单的Web应用"><a href="#完成一个简单的Web应用" class="headerlink" title="完成一个简单的Web应用"></a>完成一个简单的Web应用</h1><p>所需要的环境:  </p><ul><li>JDK17</li><li>IDEA旗舰版</li><li>Maven3</li></ul><h2 id="创建一个新项目spring01"><a href="#创建一个新项目spring01" class="headerlink" title="创建一个新项目spring01"></a>创建一个新项目spring01</h2><p><img src="/image/s1.png" alt="alt">  </p><p>向pom.xml文件添加以下部分：</p><pre><code class="hljs">    &lt;parent&gt;        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;        &lt;version&gt;2.6.13&lt;/version&gt;    &lt;/parent&gt;    &lt;dependency&gt;            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;    &lt;/dependency&gt;</code></pre><p>  <strong>注意：parent内的version要与下方properties内的spring-boot.version相同，否则就会发生冲突</strong></p><h2 id="Hello-Spring-Boot示例"><a href="#Hello-Spring-Boot示例" class="headerlink" title="Hello Spring Boot示例"></a>Hello Spring Boot示例</h2><p>  项目已为我们提供了一个有main方法的类Spring01Application </p><p>  <img src="/image/s2.png" alt="alt">  </p><p>  <strong>其中的<code>@SpringBootApplication</code>以及<code>SpringApplication.run(Spring01Application.class, args);</code>让其不再是个普通的Java类，而是使其成为一个Spring Boot应用</strong>   </p><p>  再创建一个名为HelloworldController的类，包名为com.example.spring01.controller,代码如下：<br>  <figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">  <span class="hljs-keyword">package</span> com.example.spring01.controller;<br><br><span class="hljs-keyword">import</span> org.springframework.stereotype.Controller;<br><span class="hljs-keyword">import</span> org.springframework.web.bind.<span class="hljs-keyword">annotation</span>.*;<br><br><span class="hljs-meta">@Controller</span><span class="hljs-comment">//@Controller是Spring MVC注解，表示此类用于负责处理Web请求</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">HelloworldController</span> &#123;<br>    <span class="hljs-meta">@RequestMapping(<span class="hljs-string">&quot;/say.html&quot;</span>)</span><span class="hljs-comment">//@RequestMapping是Spring MVC注解，表示如果请求路径匹配，被注解的方法将被调用</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> String say()&#123;<span class="hljs-comment">//@ResponseBody表示此方法返回的是文本，并非视图名称</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello World&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>  写了Controller,此时就可以通过浏览器访问应用<br>  <strong>注意：对于SpringBoot应用，建议启动程序Spring01Application的包名层次最高，其余类都在其下</strong>  </p><p>  在浏览器网址框输入<code>http://localhost:8080/say.html</code>，运行结果如下：</p><p>  <img src="/image/s13.png" alt="alt">   </p><p><font size="6"><b><i>访问成功！！！</i></b></font>  </p><h2 id="使用热部署"><a href="#使用热部署" class="headerlink" title="使用热部署"></a>使用热部署</h2><p>热部署通俗来讲就是随时修改程序网页随时响应   </p><p>在pom.xml文件中添加以下依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-devtools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>重启项目<br>此时修改<code>@RequestMapping(&quot;/say.html&quot;)</code>为<code>@RequestMapping(&quot;/sayhello.html&quot;)</code><br>查看控制台发现并未重启，这是因为有两个按钮未开启，如下两图所示：   </p><p><img src="/image/s14.png" alt="alt"><br><img src="/image/s15.png" alt="alt">  </p><p>开启之后热部署就可以使用了！  </p><p><strong>主要多了两个变化：由于依赖spring-boot-devtools，LiveReload server用于监控Spring Boot应用文件变化，重启时间快是因为Spring Boot再次重启，避免重启Tomcat Server和已经加载的Spring相关类，只重载变化的类</strong></p><h2 id="添加REST支持"><a href="#添加REST支持" class="headerlink" title="添加REST支持"></a>添加REST支持</h2><p>若你的系统不是单一的系统，而是由多个系统组成的，其中一个系统给其他系统提供数据，此时就用到调用方法，RESTFul就可以被考虑。  </p><p>例如新建一个UserReditRestController，添加代码<br><img src="/image/s16.png" alt="alt"> </p><p>代码中没有用到@Controller和@ResposeBody，而是使用了@RestController，可以理解为@RestController相当于@Controller和@ResposeBody  </p><p><strong>注：对于多个系统互相访问，最好不要直接访问对方的数据库，而是采用RESTFul架构，封装逻辑接口；这样对方的数据变更，业务逻辑变化都不会影响到其他系统。详细的RESTFul架构和REST支持将在后面学到</strong></p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hexo博客的搭建</title>
    <link href="/2025/03/29/Build%20individual%20blog/"/>
    <url>/2025/03/29/Build%20individual%20blog/</url>
    
    <content type="html"><![CDATA[<h1 id="搭建个人博客（Hexo框架）并部署到远端仓库"><a href="#搭建个人博客（Hexo框架）并部署到远端仓库" class="headerlink" title="搭建个人博客（Hexo框架）并部署到远端仓库"></a>搭建个人博客（Hexo框架）并部署到远端仓库</h1><h2 id="安装node"><a href="#安装node" class="headerlink" title="安装node"></a>安装node</h2><p><a href="https://nodejs.org/zh-cn">https://nodejs.org/zh-cn</a>  </p><p>使用<code>node -v</code>和<code>npm -v</code>命令检验是否安装成功<br>再输入以下命令安装Hexo（使用淘宝镜像）<br><strong><code>npm install-g cnpm --registry=https://registry.npm.taobao.org</code></strong></p><p><img src="/image/image-1.png#pic_right" alt="alt text"><br>利用<code>hexo -version</code>检验是否安装成功  </p><p><img src="/image/image-6.png" alt="alt text"></p><h2 id="安装Git及配置"><a href="#安装Git及配置" class="headerlink" title="安装Git及配置"></a>安装Git及配置</h2><p><code>https://blog.csdn.net/fanyun_01/article/details/145350857</code>   </p><p>在Git文件夹内新建文件夹blog1，右击blog1点击<code>Git Bash Here</code>,输入以下命令,创建个人博客<br><code>hexo init</code>  </p><p><img src="/image/image-2.png" alt="alt text"><br>再输入以下命令启动Hexo<br><code>hexo s</code>  </p><p><img src="/image/image-3.png" alt="alt"><br>在浏览器网址栏输入<code>https://localhost:4000/</code>  </p><p><img src="/image/image-4.png" alt="alt text"><br><em><strong>这样一个简单的个人博客就搭建好啦！</strong></em></p><h2 id="新建博客文章"><a href="#新建博客文章" class="headerlink" title="新建博客文章"></a>新建博客文章</h2><p>在blog1路径下直接输入以下命令：<br><code>hexo n &quot;我的第一篇博客.md&quot;</code>    </p><p><img src="/image/s3.png" alt="alt text"><br>文件被创建在了&#x2F;source&#x2F;_posts目录下<br>接着进入&#x2F;source&#x2F;_posts目录下<br><code>cd /source/_posts</code>  </p><p>之后就可以直接采用code（VScode）命令打开并修改md文件   </p><p><img src="/image/image-5.png" alt="alt"> </p><p><img src="/image/s5.png" alt="alt">  </p><p><strong>注意：code命令的使用需要配置环境变量</strong>   </p><blockquote><p>点击此电脑——&gt;属性——&gt;高级系统设置——&gt;环境变量——&gt; 用户变量的Path，添加VScode安装路径下的bin文件的根本路径<br><img src="/image/image-7.png" alt="alt text"></p></blockquote><p>保存修改的文件后，返回blog1目录下   (<code>cd ../../</code>)<br>输入以下命令<br><code>hexo clean</code>  &#x2F;&#x2F;清理<br><code>hexo g</code>&#x2F;&#x2F;生成<br><code>hexo s</code>&#x2F;&#x2F;启动     </p><p><img src="/image/s6.png" alt="alt">   </p><p>进入博客网页查看文件是否生成 </p><p><img src="/image/s4.png" alt="alt">     </p><h1 id="将博客部署到Gitee-Github"><a href="#将博客部署到Gitee-Github" class="headerlink" title="将博客部署到Gitee&#x2F;Github"></a>将博客部署到Gitee&#x2F;Github</h1><p><strong>由于Gitee Pages暂停服务，所以没有成功😂，但基本步骤是对的</strong>   </p><h2 id="登录Gitee-Gittub"><a href="#登录Gitee-Gittub" class="headerlink" title="登录Gitee&#x2F;Gittub"></a>登录Gitee&#x2F;Gittub</h2><p>点击右上角加号新建仓库，名称最好为<code>你的username.gitee.io</code>，仓库介绍随意写，点击创建即可 </p><p>接着在blog1目录下输入<code>dir</code>查看所有文件，看到存在_config.yml文件，输入以下命令<code>code _config.yml</code>修改配置文件,如下图所示：<br><img src="/image/s8.png" alt="alt"><br>上图内容修改为以下内容：<br><img src="/image/s7.png" alt="alt"><br><strong>注意：repo是指新建的gitee或github仓库的地址</strong><br>我的github仓库地址：<a href="https://github.com/Alder-djr/Alder-djr.github.io.git">https://github.com/Alder-djr/Alder-djr.github.io.git</a> </p><p>接着在blog1目录下输入<code>hexo d</code>远程部署到gitee&#x2F;github平台   </p><p><img src="/image/s9.png" alt="alt">   </p><p><img src="/image/s11.png" alt="alt"> </p><p><img src="/image/s10.png" alt="alt"><br>这样我们的远程仓库就多了很多文件 </p><p>后续如果我们想要打开我们的博客就不需要再命令行里输入<code>hexo s</code>了，直接在网址栏输入上面红框中的内容即可   </p><p><strong>注意：edge浏览器要在前面加上https:&#x2F;&#x2F;</strong>  </p><p>当然我这网页不可访问&#x2F;(ㄒoㄒ)&#x2F;~~  </p><p><img src="/image/s12.png" alt="alt">   </p><p style="color:red">注意：还有一个坑</p> 如果要将其他文件夹的md文件直接复制或移动到/source/_posts目录下，要在文件内容开头加上以下内容，否则无法上传到博客中 <pre><code class="hljs">---title: Hexo博客date: 2025-03-29categories:  - Hexo博客tags:  - Hexo博客---</code></pre><p>title：博客标题；categories：目录；tags：标签   </p><p><strong>另外，如果文件有大幅度修改或创建，还需要执行以下两个命令才能上传至博客中</strong> </p><p><code>hexo clean</code></p><p><code>hexo g</code></p>]]></content>
    
    
    <categories>
      
      <category>Hexo博客</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Hexo博客</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring框架的产生及Spring Boot的推出</title>
    <link href="/2025/03/29/Spring01/"/>
    <url>/2025/03/29/Spring01/</url>
    
    <content type="html"><![CDATA[<h1 id="Spring框架的产生"><a href="#Spring框架的产生" class="headerlink" title="Spring框架的产生"></a>Spring框架的产生</h1><p>由于JavaEE框架的复杂性（比如假定的分布式系统），Spring是为了解决应用复杂性而产生的框架，它提供两种机制：控制反转（IoC）和面向切面（AOP），来提供任意的服务和增强Bean的任意特性，使得Spring本身容易掌握，又可以通过Bean管理来无限扩展功能。</p><p>注：Bean 是java中的类，通常用于封装数据、业务逻辑或服务。</p><h2 id="IOC"><a href="#IOC" class="headerlink" title="IOC"></a>IOC</h2><p>IOC Core Container:Spring Container负责管理你的任意对象，并结合你对对象的描述进行初始化和加强</p><h6 id="例子："><a href="#例子：" class="headerlink" title="例子："></a>例子：</h6><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Controller</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloworldController</span></span>&#123;<br>    <span class="hljs-variable">@RequestMapping</span>(<span class="hljs-string">&quot;/sayhello.html&quot;</span>)<br>    public <span class="hljs-variable">@RequestBody</span> String <span class="hljs-keyword">say</span>(String name)&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>+name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，Spring Container在容器中初始化HelloworldController实例后，对于客户端发起的&#x2F;sayhello.html请求，会执行say方法，并自动将请求参数按照say方法声明的名称一一对应。</p><p><strong>Spring通常提供一些注解：@controller、@Service、@Component、@Configuration,只有使用这些注解才能引起Spring容器的注意，并根据注解含义来管理和增强对象</strong></p><figure class="highlight perl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs perl"><span class="hljs-variable">@Controller</span><br>public <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloworldController</span></span>&#123;<br>    <span class="hljs-variable">@Autowired</span> UserService userService;<br>&#125;<br></code></pre></td></tr></table></figure><p>在上面的例子中，类UserService被@Service注解了，在类HelloworldController中，使用@Autowired自动注入这个实例</p><h2 id="AOP"><a href="#AOP" class="headerlink" title="AOP"></a>AOP</h2><p>AOP指面向切面编程，通过预编译方式或者运行时刻对目标对象动态地添加功能。例如要实现用户访问控制，可以对每个Controller的方法使用一个自定义的注解Function，用Spring AOP向Controller每个方法动态地添加用户权限校验功能。例子如下：</p><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/sayhello.html&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">say</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span>+name;<br>&#125;<br><br><span class="hljs-meta">@RequestMapping</span>(<span class="hljs-string">&quot;/adduser.html&quot;</span>)<br><span class="hljs-meta">@Function</span>(<span class="hljs-string">&quot;user.add&quot;</span>)<br><span class="hljs-keyword">public</span> <span class="hljs-meta">@ResponseBody</span> <span class="hljs-title class_">String</span> <span class="hljs-title function_">addUser</span>(<span class="hljs-params"><span class="hljs-title class_">String</span> name</span>)&#123;<br>    ......<br>&#125;<br></code></pre></td></tr></table></figure><p>注解Function是自定义的一个注解，接受一个字符串，表示Controller方法对应的业务功能，用户是否能访问“user.add”功能，将在数据库中配置。</p><h2 id="Spring的缺点"><a href="#Spring的缺点" class="headerlink" title="Spring的缺点"></a>Spring的缺点</h2><ul><li>使用门槛高，入门Spring需很长时间</li><li>对过时技术兼容，导致使用复杂度高（比如处理事务使用XML还是注解@Trasaction）<br>Trasaction：Deposit(&#x2F;dɪˈpɒzɪt&#x2F;) money into or withdraw money from a bank account.</li><li>XML配置已不再流行</li><li>集成第三方工具时，程序员还要考虑工具之间的兼容性</li><li>系统启动慢，不具备热部署功能，完全依赖虚拟机或Web服务器的热部署</li></ul><h2 id="SpringBoot的推出"><a href="#SpringBoot的推出" class="headerlink" title="SpringBoot的推出"></a>SpringBoot的推出</h2><p>基于Spring的缺点，Spring开发人员推出SpringBoot，解决了以上缺点，<strong>SpringBoot能激素开发Web系统，更容易架构大的分布式系统</strong></p><hr><p>SpringBoot管理Spring容器、第三方插件，并提供很多默认系统级的服务，无论是简单的Web系统还是负复杂的系统，都只需要少量配置和代码就能完成。   </p><ul><li>SpringBoot通过Starter来提供系统级服务</li></ul><p>如果要开发一个Web应用，只需要在pom.xml中声明一下代码即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>以下是SpringBoot提供的常用Starter  ：</li></ul><table><thead><tr><th>名称</th><th>作用</th></tr></thead><tbody><tr><td><code>spring-boot-starter</code></td><td>核心 Starter，包括自动配置支持、日志库和 YAML</td></tr><tr><td><code>spring-boot-starter-web</code></td><td>用于构建 Web 应用程序，包括 Spring MVC 和 Tomcat</td></tr><tr><td><code>spring-boot-starter-data-jpa</code></td><td>用于 Spring Data JPA 与 Hibernate，便于数据库操作</td></tr><tr><td><code>spring-boot-starter-security</code></td><td>提供 Spring Security 支持，用于添加安全和身份验证</td></tr><tr><td><code>spring-boot-starter-test</code></td><td>提供用于测试 Spring Boot 应用的库，如 JUnit、Hamcrest 和 Mockito</td></tr><tr><td><code>spring-boot-starter-jdbc</code></td><td>用于支持 JDBC 数据库访问和数据库池配置</td></tr><tr><td><code>spring-boot-starter-cache</code></td><td>提供缓存支持，例如 EhCache、Caffeine 或简单的内存基缓存</td></tr><tr><td><code>spring-boot-starter-actuator</code></td><td>提供生产级别的应用监控和管理功能</td></tr><tr><td><code>spring-boot-starter-mail</code></td><td>用于支持发送电子邮件</td></tr><tr><td><code>spring-boot-starter-aop</code></td><td>包括 spring-aop 和 AspectJ，支持面向切面编程</td></tr><tr><td><code>spring-boot-starter-batch</code></td><td>用于支持 Spring Batch，一个批量处理框架</td></tr><tr><td><code>spring-boot-starter-data-redis</code></td><td>用于 Spring Data Redis 和 Lettuce 客户端的 Redis 键值数据存储</td></tr><tr><td><code>spring-boot-starter-data-mongodb</code></td><td>用于 MongoDB 文档数据库和 Spring Data MongoDB</td></tr><tr><td><code>spring-boot-starter-data-elasticsearch</code></td><td>用于 Elasticsearch 搜索和分析引擎以及 Spring Data Elasticsearch</td></tr><tr><td><code>spring-boot-starter-websocket</code></td><td>用于构建 WebSocket 应用程序</td></tr><tr><td><code>spring-boot-starter-thymeleaf</code></td><td>用于使用 Thymeleaf 视图构建 MVC Web 应用程序</td></tr><tr><td><code>spring-boot-starter-freemarker</code></td><td>用于使用 FreeMarker 视图构建 MVC Web 应用程序</td></tr><tr><td><code>spring-boot-starter-mustache</code></td><td>用于使用 Mustache 视图构建 MVC Web 应用程序</td></tr></tbody></table><h2 id="SpringBoot相对于Spring的优点"><a href="#SpringBoot相对于Spring的优点" class="headerlink" title="SpringBoot相对于Spring的优点"></a>SpringBoot相对于Spring的优点</h2><ul><li>实现约定大于配置，是一个低配置的应用系统框架，且能够使用Spring的大量功能  </li><li>提供内置的Tomcat或者Jetty容器  </li><li>通过依赖jar包管理、自动装配技术，容易支持与其他技术体系、工具集成  </li><li>支持热加载，开发体验好，也支持SpringBoot系统监控，方便了解系统运行状态</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
